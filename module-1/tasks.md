# Задачи

## Задача 1

В академичните публикации е прието при наличие на повече няколко автори с имейли с еднакви домейни, техните имена да се обединяват.

Т.е. за краткост `name1@domain`, `name2@domain` се изписват вместо това като `{name1,name2}@domain`.

Напишете функция `emails_shortener`, която приема `emails` (списък от низове) и връща множество (`set`) от низове, където всички имейли с еднакви домейни са обединени по гореописания начин.

*Hint 1*: за да разделите низ `s` по даден символ `c`, изполвайте [`s.split(c)`](https://docs.python.org/3/library/stdtypes.html#str.split). Връща лист с всяка разбита част (низ).

*Hint 2*: низове се слепват с метода [`join`](https://docs.python.org/3/library/stdtypes.html#str.join). Например `":".join(["john", "doe", "jr"])` ще върне `"john:doe:jr"`.

*Hint 3*: в `set` се добавя елемент с метода `add`.

## Задача 2

Turtle е библиотека в Python, която предоставя опростен начин за рисуване чрез графичен интерфейс. С нея може да се създават различни форми, фигури и анимации, като се използва костенурка - виртуален курсор, който се движи по екрана и оставя следи. Вашата задача днес е вдъхновена именно от нея и е следната:

Създайте клас `Turtle`.

При създаване на обект от класа Turtle трябва да бъдат приети 2 параметъра - `x` и `y`, координатите на стартовата точка на вашата костенурка по оста x и оста y. Ако такива не бъдат подадени, се приема, че стартовата точка е с координати (0,0).

Имплементирайте метод `get_current_position`, който да връща **tuple** с координатите на настоящата позиция на костенурката.

Костенурката трябва да може да се движи. За целта трябва да бъде написан метод `move`, който да приема произволен брой аргументи - команди за движение. Ако се подаде невалидна команда (т.е. различна от позволените) да се покаже на конзолата съобщение `Invalid command: {command}`, но да не се прекъсва хода на метода.
Вашата костенурка може да изпълнява само следните 4 движения:

- `up` - премества се 1 стъпка нагоре по координатната система
- `down` - премества се 1 стъпка надолу по координатната система
- `left` - премества се 1 стъпка наляво по координатната система
- `right` - премества се 1 стъпка надясно по координатната система

Костенурката може да има различни конфигурации. Тя може да рисува в определен цвят, да оставя диря с точно определена дебелина и т.н. Имплементирайте метод `configure_turtle`, който да приема произволен брой аргументи - конфигурационните параметри и техните стойности. Да се връща низ от вида `Current configuration: {P}:{V} | {P}:{V} |...`, където **P** е името на конфигурационния параметър, а **V** е неговата стойност.  

Трябва да можем да проверим дали сме изобразили точно определна рисунка. Под рисунка разбираме конкретна последователност от команди. 
Вашата задача е да имплементирате метод `check_for_drawing`, който приема последователност от команди (рисунка) и връща bool, който индикира дали такава е била нарисувана.

- *Пример за рисунка*: **[up, up, up, right, right, down, left, left]**.

Като за финал пренапишете `__str__`, така че да връща следното съобщение: `Turtle is at position ({x}, {y}) and has moved {count} times since start`

## Задача 3

В шахa, конят се движи по един от следните начини:

- две полета хоризонтално и едно вертикално
- две полета вертикално и едно хоризонтално

![Chess](https://i.imgur.com/jRvOJaK.png)

Напомняме, че редовете се номерират от 1 до 8, а колоните - от A до H.
В случая, нашият кон е на позиция `d4`.
Той може да се премести на следните позиции: `e7`, `f6`, `f4`, `e3`, `c3`, `b4`, `b6`, `c7`

Напишете генератор, който приема начална позиция на кон, и връща всички възможни ходове.

## Задача 4

За ефективна работа с изображения, тяхното представяне много често е във вид на матрица.
Целта на тази задача е да се имплементират няколко прости операции върху изображения (матрици).

За улеснение, матрица дефинираме като двумерен списък с размер `MxN` (`M` реда, и `N` колони) и елементи цели числа.

Напишете следните функции, които модифицират даден матрица:

- `rotate_clockwise` - завърта матрицата в посока на часовниковата стрелка
- `rotate_counterclockwise` - завърта матрицата в посока обратна на часовниковата стрелка
- `flip_horizontal` - връща огледална матрица, в хоризонтална посока
- `flip_vertical` - връща огледална матрица, във вертикална посока

Или казано по друг начин:

$$ A = \begin{pmatrix}1 & 2 & 3\\ 4 & 5 & 6\\ 7 & 8 & 9\end{pmatrix} $$

$$ rotate\_clockwise(A) = \begin{pmatrix}7 & 4 & 1\\ 8 & 5 & 2\\ 9 & 6 & 3\end{pmatrix} $$
$$ rotate\_counterclockwise(A) = \begin{pmatrix}3 & 6 & 9\\ 2 & 5 & 8\\ 1 & 4 & 7\end{pmatrix} $$
$$ flip\_horizontal(A) = \begin{pmatrix}3 & 2 & 1\\ 6 & 5 & 4\\ 9 & 8 & 7\end{pmatrix} $$
$$ flip\_vertical(A) = \begin{pmatrix}7 & 8 & 9\\ 4 & 5 & 6\\ 1 & 2 & 3\end{pmatrix} $$

## Задача 5

Напишете декоратор на име `sdrawkcab` със следното поведение:

- Ако резултатът от функцията е от тип `str`, връща низът обърнат отзад-напред
- Ако резултатът е от тип `list`:
  - За всеки елемент тип `str` в списъка, прилага горната трансформация.
  - Всички други елементи не се променят.
- Ако резултатът от функцията не е `str`, връща резултата без промяна.

## Задача 6

`LAIKA` е алгоритъм с *неизвестни* създадели, който има за цел да кодира и дистрибутира информация.

`LAIKA` алгоритъма работа с низове, като ги разделя и кодира на отделни парчета.

Кодирането е симетрично, като първият символ се поставя на първа позиция, следващият на последна позиция, този след него на 2-ра, този след него на предпоследна, и т.н.:

"abcdefg" => "acegfdb"

`LAIKA` се нуждае и от параметър `n`, който разделя **кодираното** съобщение на части с размер `n`.

Например, прилагайки `LAIKA` с разделяне на части с дължина 5, върху низът "Hello, this is a secret message", ще получим следният резултат:

`"Hello, this is a secret message" => "Hlo hsi  ertmsaegse ecsas it,le" => 'Hlo h', 'si  e', 'rtmsa', 'egse ', 'ecsas', ' it,l', 'e'` (вторият елемент има два последователни символа за празно място)

Така, за да може да се разчете нашето съобщение, ще са необходими всичките му части.

От вас се изисква да имплементирате алгоритъма, като създадете клас `LAIKA`, със следните методи:

- Конструкторът на класът приема два аргумента - път до директория, в която ще се съхраняват резултатите файлове (повече за тях, по-долу), и цяло число `caesar_key`.
- `encode` - приема низ и цяло число `n`, и връща резултата от `LAIKA` кодирането върху него
- `decode` - приема списък от низове кодирани с `LAIKA`, и връща оригиналния вход

- `encode_to_files` - приема низ и цяло число `n`, кодира съдържанието, и записва всяка една от отделните части в отделни файлове под директорията, подадена в конструктора. Като резултат връща името на **първия** файл от поредицата. Ако някой от файлове вече съществува, трябва да се хвърли `FileExistsError`

- `decode_from_files` - приема името на **първият** файл от поредица кодирани файлове. Прочита файлове и декодира тяхното съдържание. Връща низ с оригиналното съдържание. Ако някой от очакваните файлове не съществува, трябва да се хвърли `FileNotFoundError`.

Структурата на всеки от файловете е следната:

- Името на файла е получено чрез прилагането на [Шифърът на Цезар](https://en.wikipedia.org/wiki/Caesar_cipher) с ключ `caesar_key` върху съдържанието.
- На първият ред от файла се записва името на **следващият** файл от поредицата. (При последният файл, просто запишете празен ред)
- На вторият ред от файла се записва кодираното съдържание.

### Пример

Създаваме `LAIKA` обект, с аргументи `temp` (за директория), и `caesar_key=4`

Ако извикаме `encode_to_files('abcdefg', 4)`, ще получим два файла - `egik` и `jhf`.
Тяхното съдържание съответно е:

```plaintext
jhf
aceg
```

и

```plaintext
 
fdb
```

То е получено по следният начин. 'abcdefg' се кодира до: `['aceg', 'fdb']`
Името на първият файл е получено като приложим шифъра на Цезър върху `aceg` => `egik`.
Името на вторият файл е получено по същия начин - `fdb` => `jhf`.

### Бележки и подсказки

- Можем да си представим, че имаме свързан списък, от файлове. Всеки файл държи кой е следващият, както и съдържанието си.
- Кодиране с шифъра на Цезър: ${\displaystyle E_{n}(x)=(x+n)\mod {26}}$, където $x$ е ASCII кода на буквата, а $n$ е ключа.
- Приемаме,че съобщението което ще кодираме ще е съставено от букви, цифри и празни места. Няма да има табулации, празни редове и т.н.
- `encode_to_files` и `decode_from_files` приемат и връщат само името на файла.
